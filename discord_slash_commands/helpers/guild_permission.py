"""Stores what users have what permissions for this bot in each guild.

This file defines classes and functions for storing what users have what
permissions for this bot in what guilds. This bot does not need or want to
create or modify guild roles. The less permissions the better.
"""
# TODO: ... unless guild roles are the only way to get accurate member cache
#       lists
# TODO: Make each guild have its own JSON folder so classes don't need to care
#       about guild IDs
# TODO: Make JSONDict classes and switch many classes to that.
#       JSONList is still neccessary, but not ideal for everything.

#==============================================================================#
# Import libraries                                                             #
#==============================================================================#

# Import operating system module
import os

# Import function for loading environment variables
from dotenv import load_dotenv

# Import Discord Python API
import discord

# Custom class for interfacing with JSON files
import discord_slash_commands.helpers.json_list as json_list

#==============================================================================#
# Define underlying structure                                                  #
#==============================================================================#

def get_bot_owner_discord_user_id() -> int:
    """Get the Discord user ID of the bot owner.

    Get the Discord user ID of the owner of this bot from the environment
    variable BOT_OWNER_DISCORD_USER_ID set in .env.

    Returns:
        The bot owner's Discord user ID as an integer.
    """
    load_dotenv()
    return int(os.getenv("BOT_OWNER_DISCORD_USER_ID"))



class GuildPermission(json_list.JSONListItem):
    """Define an instance of info held on a guild for permissions on this bot.

    Define the different types of roles a user can have in this guild for this
    bot and the state of the bot in this guild. For example, a user may be
    blacklisted from using the bot in this guild or commands from non-trusted
    users may be disabled.

    Attributes:
        guild_id: The ID of the guild these permissions will apply to
        is_locked: When the server is 'locked', it will refuse to accept most
            commands from non-admin users. Locking the bot is useful for
            temporarily blocking spam, small debugging, and small maintenance.
        dict_of_user_id_list: A dictionary holding the different types of
            permissions a user can have in a guild.
    """
    def __init__(
        self,
        guild_id: int = 0,
        is_locked: bool = False,
        blacklist_user_id_list: list = [],
        admin_user_id_list: list = [get_bot_owner_discord_user_id()]
    ):
        """Initialize this GuildPermission.

        Set the members of this GuildPermission to the passed in or default
        values.

        Args:
            guild_id: What to initialize self.guild_id as
            is_locked: What to initialize self.is_locked as
            blacklist_user_id_list: What to initialize
                self.dict_of_user_id["blacklisted"] as
            admin_user_id_list: What to initialize
                self.dict_of_user_id["admin"] as
        """
        self.guild_id = guild_id
        self.is_locked = is_locked
        self.dict_of_user_id_list = {
            # A list of what user IDs are not allowed to use my commands
            # in this guild. Useful for, for example, blocking someone from
            # using TTS nefariously, while someone else still needs to use it
            # legitimately.
            "blacklisted": blacklist_user_id_list,
            # A list of what user IDs I trust to call my more sensitive
            # commands, for example, killing the bot and blacklisting others
            "admin": admin_user_id_list
        }

    def to_dict(self) -> dict:
        """Return this GuildPermission as a dictionary.

        Create a new dictionary, where each key coressponds to a member of this
        GuildPermission.

        Args:
            self: This GuildPermission

        Returns:
            A copy of this GuildPermission as a dictionary.
        """
        return {
            "gid": self.guild_id,
            "locked": self.is_locked,
            "uid_dict": self.dict_of_user_id_list,
        }

    def from_dict(self, dictionary: dict) -> None:
        """Read this GuildPermission from a dictionary.

        Read a dictionary, following the same format as what as generated by
        self.to_dict(), and overwrite each member with its key values.

        Args:
            self: This GuildPermission
            dictionary: The dictionary to read
        """
        self.guild_id = dictionary["gid"]
        self.is_locked = dictionary["locked"]
        self.dict_of_user_id_list = dictionary["uid_dict"]

    def copy(self):
        """Return a copy of this GuildPermission.

        Create a new GuildPermission with the same members as this one and
        return it.

        Args:
            self: This GuildPermission

        Returns:
            A copy of this GuildPermission.
        """
        return GuildPermission(
            self.guild_id,
            self.is_locked,
            self.dict_of_user_id_list["blacklisted"],
            self.dict_of_user_id_list["admin"],
        )



class GuildPermissionBank(json_list.JSONList):
    """Define a list of info held on each guild for permissions on this bot.

    Define a custom instance of JSONList to hold GuildPermission, with extra
    helper functions. See json_list.py for class members and their descriptions.
    """
    def modify_user_id_list(
        self,
        list_name: str,
        list_operation: str,
        user_id: int,
        guild_id: int
    ) -> bool:
        """Add or remove a user from a 'role' in a given guild.

        Add or remove a user from a permission list for a given guild. The
        operation may be denied for file IO reasons or if the operation wouldn't
        actually result in a change in self.list.

        Args:
            self: This GuildPermissionBank
            list_name: The key in GuildPermission.dict_of_user_id_list to modify
                the list of
            list_operation: The type of operation you wish to do on
                GuildPermission.dict_of_user_id_list[list_name]. For now the
                only options are to "add" or "remove" the passed in user_id.
            user_id: The ID of the user you wish to "add" or "remove" from
                GuildPermission.dict_of_user_id_list[list_name]
            guild_id: The ID of the guild to modify user_id's permissions in

        Returns:
            Whether the operation changed self.list and the changes were saved.
        """
        # TODO: make it possible to deny for file IO reasons
        # Do not allow illegal operations or operands
        if list_name not in ("blacklisted", "admin") or \
            list_operation not in ("add", "remove"):
            return False

        # Get the latest updates
        self.sync()

        # Get or create a GuildPermission for guild_id
        match_index = self.get_list_item_index(
            lambda user_privelage, guild_id:
                user_privelage.guild_id == guild_id,
            guild_id
        )
        if match_index < 0:
            match_index = len(self.list)
            self.list.append(GuildPermission(guild_id))

        # Do list_operation, don't self.write() if it doesn't modify any data
        # TODO: test this is a reference and works as expected
        user_id_list = self.list[match_index].dict_of_user_id_list[list_name]
        if list_operation == "add":
            if user_id in user_id_list:
                return False
            user_id_list.append(user_id)
        elif list_operation == "remove":
            if user_id not in user_id_list:
                return False
            user_id_list.remove(user_id)

        # Save the latest updates
        self.write()
        return True

    def get_user_id_list(
        self,
        list_name: str,
        guild_id: int
    ) -> list:
        """Get GuildPermissions.dict_of_user_id_list[list_name] for guild_id.

        Get the list of the IDs of what users have the permission list_name
        in the guild matching guild_id.

        Args:
            self: This GuildPermissionBank
            list_name: The key in GuildPermission.dict_of_user_id_list to get
                the list of
            guild_id: The ID of the guild to get
                GuildPermission.dict_of_user_id_list[list_name] for

        Returns:
            GuildPermission.dict_of_user_id_list[list_name] for the guild
            matching guild_id, if it exists, otherwise an empty list.
        """
        # Do not allow illegal operations
        if list_name not in ("blacklisted", "admin"):
            return []

        # Get the latest changes
        self.sync()

        # Get or create a GuildPermission for guild_id
        match_index = self.get_list_item_index(
            lambda user_privelage, guild_id:
                user_privelage.guild_id == guild_id,
            guild_id
        )
        if match_index < 0:
            match_index = len(self.list)
            self.list.append(GuildPermission(guild_id))

        # Return match
        return self.list[match_index].dict_of_user_id_list[list_name]

    def user_has_permission(
        self,
        list_name: str,
        user_id: int,
        guild_id: int
    ) -> bool:
        """Check if user_id has the permission list_name in guild_id.

        See if GuildPermissions.dict_of_user_id_list[list_name] for the guild
        matching guild_id contains user_id.

        Args:
            self: this GuildPermissionBank
            list_name: The key in GuildPermission.dict_of_user_id_list to check
                the list of
            user_id: The ID of the user you wish to assert is in
                GuildPermissions.dict_of_user_id_list[list_name].
            guild_id: The ID of the guild to check
                GuildPermission.dict_of_user_id_list[list_name] for

        Return:
            Whether user_id is in
            GuildPermissions.dict_of_user_id_list[list_name] for guild_id.
        """
        # If querying whether the user is a bot owner,
        # can do a simple check and exit early
        if list_name == "bot owner":
            return user_id == get_bot_owner_discord_user_id()

        # Return whether the user is in the list of people with this permission
        return user_id in self.get_user_id_list(list_name, guild_id)

    def set_is_locked(
        self,
        new_lock_value: bool,
        guild_id: int
    ) -> None:
        """Set if the bot is accepting commands from non-admins for guild_id.

        Set whether the bot is accepting commands from non-admins for the bot
        for guild_id. Setting this to True is useful for things like small
        run-time cleanup, maintenence, and debugging. Locked is not a state
        the bot is meant to stay in indefinitely, because adding and removing
        admins for the bot can only be done by the bot owner, and admins cannot
        be blacklisted, but it'll still work.

        Args:
            self: this GuildPermissionBank
            new_lock_value: What to set GuildPermission.is_locked to
            guild_id: The ID of the guild to modify GuildPermission.is_locked of
        """
        # TODO: make it so function can fail for file IO or duplicate values
        # Get the latest updates
        self.sync()

        # Get or create a GuildPermission for guild_id,
        # if no changes will happen, don't save them
        match_index = self.get_list_item_index(
            lambda user_privelage, guild_id:
                user_privelage.guild_id == guild_id,
            guild_id
        )
        if match_index < 0:
            match_index = len(self.list)
            self.list.append(GuildPermission(guild_id))
        elif self.list[match_index].is_locked == new_lock_value:
            return

        # Set the new is_locked value
        self.list[match_index].is_locked = new_lock_value

        # Save the latest updates
        self.write()

    def get_is_locked(
        self,
        guild_id: int
    ) -> bool:
        """Get if the bot is accepting commands from non-admins for guild_id.

        Set whether the bot is accepting commands from non-admins for the bot
        for guild_id. If no GuildPermission exists for guild_id, make one with
        default values.

        Args:
            self: this GuildPermissionBank
            guild_id: The ID of the guild to get GuildPermission.is_locked for

        Return:
            The value of GuildPermission.is_locked for guild_id. If one doesn't
            exist for guild_id, the default is_locked value.
        """
        # Get the latest updates
        self.sync()

        # Get or create a GuildPermission for guild_id
        match_index = self.get_list_item_index(
            lambda user_privelage, guild_id:
                user_privelage.guild_id == guild_id,
            guild_id
        )
        if match_index < 0:
            match_index = len(self.list)
            self.list.append(GuildPermission(guild_id))

        # Return whether this guild is_locked
        return self.list[match_index].is_locked



# Create class instances
guild_permission_instance = GuildPermission()
guild_permission_bank = GuildPermissionBank(
    file_directory = "json",
    file_name = "user_permission_bank.json",
    list_type_instance = guild_permission_instance,
    #max_file_size_in_bytes = default
)
