"""Custom class for perisistent memory able to be shared by multiple threads.

This file defines a custom class for letting you store lists in JSON, enabling
you to have perisisent memory, and reads from and writes to storage as
infrequently as possible, while also staying up-to-date with changes made by
other threads. It does not work in its base state and is meant to be used as a
template. See examples in other files such as tts.py.
"""

#==============================================================================#
# Import libraries                                                             #
#==============================================================================#

# Import API for JSON reading, writing, and parsing
import json

# Import operating system API for handling things like moving files
import os

# Import API for handling time
import time

# Import Callable type
from typing import Callable

#==============================================================================#
# Define underlying structure                                                  #
#==============================================================================#

class JSONListItem:
    """This class defines an element in JSONList.list

    To make a class storable by JSONList, the elements of JSON.list must write
    implementions for these virtual methods. Members for this class can be added
    by you when defining children of this class.
    """
    def to_dict(self) -> dict:
        """Convert the members of this class into a dict.

        Return a dict where each keys coresponds to a member of this
        JSONListItem.

        Args:
            self: This JSONListItem

        Returns:
            A dict containing each member of this JSONListItem.
        """
        raise NotImplementedError

    # Read member variables from dictionary
    def from_dict(self, dictionary: dict) -> None:
        """Read members of this class from a dict.

        Read a dict matching the format generated by self.to_dict back into
        this JSONListItem's members. This is how your JSONListItems will be
        automatically repopulated from storage when the bot restarts.

        Args:
            self: This JSONListItem
            dictionary: The dictionary to read member values from
        """
        raise NotImplementedError

    # Return a copy of this JSONListItem (by value, not by reference)
    def copy(self):
        """Return a copy of this JSONListItem.

        Return a copy, instead of a reference to, this JSONListItem. This is so
        that when using JSONList.list_type_instance to parse JSON, and appending
        it to JSONList.list, each element appended will not be the same.

        Args:
            self: This JSONListItem

        Returns:
            A JSONListItem with the same member values as this JSONListItem.
        """
        raise NotImplementedError



class JSONList:
    """This class defines a list that'll read from and write to JSON files.

    This class lets you handle lists that you plan to keep between bot sessions.
    It keeps what's in memory and storage in sync best it can, between all the
    threads and asynchronous file operations it can, whether you, the bot owner,
    make changes in the background, or other threads do. It tries to do all this
    while making expensive file IO operations the least possible.
    There might be other ways to handle this, but this doesn't require
    additional servers and is self-contained.

    Attributes:
        file_directory: The directory of the JSON file to read from and write to
        file_name: The name of the JSON file to read from and write to
        file_path: The path of the JSON file to read from and write to
            (made from file_directory and file_name)
        last_sync: The timestamp of when the JSON file and memory were last
            synced (self.read or self.write was called). Measured in seconds
            since the last epoch, see:
            https://docs.python.org/3/library/time.html.
        list: The contents of the JSON file, see if it is out of sync with the
            file via self.is_desynced. The contents of the JSON file are
            expected to be a list of dicts, where each dict will then be
            converted into the same type as self.list_type_instance.
        list_type_instance: The type of an individual self.list element
        max_file_size_in_bytes: The max size the JSON file is allowed to get to,
            to prevent bloat on the bot's computer
    """
    def __init__(
        self,
        file_directory: str,
        file_name: str,
        list_type_instance: JSONListItem,
        max_file_size_in_bytes: int = 50000
    ):
        """Initialize the members of JSONList to default values, then read.

        Set each member of this class instance to default values or the passed
        in arguments, then attempt to read the file pointed at by self.path to
        have accurate values for self.list and self.last_sync.

        Args:
            self: This JSONList
            file_directory: What to initialize self.file_directory as
            file_name: What to initialize self.file_name as
            list_type_instance: What to initialize self.list_type_instance as
            max_file_size_in_bytes: What to initialize
                self.max_file_size_in_bytes as
        """
        self.file_directory = file_directory
        self.file_name = file_name
        self.file_path = f"{self.file_directory}/{self.file_name}"
        self.last_sync = 0
        self.list = []
        self.list_type_instance = list_type_instance
        self.max_file_size_in_bytes = max_file_size_in_bytes
        # Actually read the JSON file to populate self.last_sync and self.list
        self.read()

    def file_size_is_too_big(self, length_in_bytes: int) -> bool:
        """Check whether an amount of data is too large to read or write.

        This class will refuse to read or write files larger than
        self.max_file_size_in_bytes. This is to prevent bloat and attacks on
        the bot owner's computer.

        Args:
            self: This JSONList
            length_in_bytes: The length we want to know if is too large to be
                accepted for read or write

        Returns:
            Whether length_in_bytes is too big for JSONList to read or write.
        """
        # Check if the file size is at or near threshold
        if length_in_bytes * 0.75 > self.max_file_size_in_bytes:
            # Give the bot owner a warning with possible solutions
            print(f"{self.file_path} is full or near full, at " \
                + f"{length_in_bytes} bytes of {self.max_file_size_in_bytes} " \
                + "max bytes." \
                + "\nPlease consider some counter-measures, such as:" \
                + "\n 1. Lock the bot, make a backup of the JSON file, " \
                + "manually remove uneeded info from it, unlock the bot." \
                + "\n 2. Kill the bot, increase the max file size for this " \
                + "JSON file, restart the bot." \
                + "\n 3. Optimize the code, such as the to_dict and " \
                + "from_dict methods, or use a database to store information " \
                + "instead of JSON files.")

            # If the length_in_bytes is over threshold, return True
            if length_in_bytes > self.max_file_size_in_bytes:
                return True

        # The file is not over threshold, return False
        return False

    # TODO: callers are not currently checking the return value of this
    def read(self) -> bool:
        """Read the contents of self.file_path into self.list.

        This class expects that the JSON file being read is a list of
        dictionaries. That list of dictionaries will be parsed into classes,
        so self.list is a list of the same type as self.list_type_instance.
        The bot owner will be told via console the details of the error if there
        was one.

        Args:
            self: This JSONList

        Returns:
            Whether the file read operation was successful. It can fail for a
            variety of reasons, such as invalid permissions, the file not
            existing, or the file not being in the correct format.
        """
        # If self.file_path doesn't exist don't bother reading it
        if not os.path.exists(self.file_path):
            print(f"Could not find, and therefore read from {self.file_path}.")
            return False

        # Don't read a file that's too big
        if self.file_size_is_too_big(os.path.getsize(self.file_path)):
            print(f"{self.file_path} is too big, refusing to read it.")
            return False

        # Open self.file_path for reading
        file_handle = None
        read_time = time.mktime(time.localtime())
        try:
            file_handle = open(self.file_path, "r")
        except OSError:
            print(f"{self.file_path} exists, but cannot be read.")
            return False

        # Read the contents of self.file_path as JSON, a list of dictionaries
        json_read = None
        try:
            json_read = json.load(file_handle)
            file_handle.close()
        except json.JSONDecodeError:
            print(f"{self.file_path} exists, " \
                + "but there was an error parsing it as JSON.")
            file_handle.close()
            return False

        # Log time of read
        self.last_sync = read_time

        # Parse contents of JSON read as a list of dictionaries
        self.list = []
        for dictionary in json_read:
            self.list_type_instance.from_dict(dictionary)
            self.list.append(self.list_type_instance.copy())

        # Return success
        return True

    # TODO: callers are not currently checking the return value of this
    def write(self) -> True:
        """Save the contents of self.list to self.file_path.

        Write the contents of self.list into self.file_path as a JSON list of
        dictionaries, overwriting any previous file there. The bot owner will
        be told via console the details of the error if there was one.

        Args:
            self: This JSONList

        Returns:
            Whether the file write operation was successful. It can fail for a
            few reasons, such as the amount of data to write being too large or
            the os refusing to write the file.
        """
        # Create a list of dicts to save to self.file_path
        list_of_dict = []
        for list_item in self.list:
            list_of_dict.append(list_item.to_dict())

        # Compute the JSON that will be dumped into the file,
        # refuse if it's too big
        json_dump = json.dumps(list_of_dict)
        if self.file_size_is_too_big(len(json_dump)):
            print(f"The contents wishing to be written to {self.file_path} " \
                + "would take too much space, refusing to write it.")
            return False

        # Write to self.file_path,
        # will overwrite old contents and make new file if one did not exist
        try:
            file_handle = open(self.file_path, "w")
            file_handle.write(json_dump)
            file_handle.close()
        except OSError:
            print(f"{self.file_path} could not be written to.")
            return False

        # Log time of write
        self.last_sync = time.mktime(time.localtime())

        # Return success
        return True

    def get_list_item_index(
        self,
        search_function: Callable,
        search_match
    ) -> int:
        """Get the index of an item from self.list found via search_function.

        Run search_function on each member in self.list(), and return the first
        element in self.list that makes it return True for search_match. See
        examples in other files, such as tts.py.

        Args:
            self: This JSONList
            search_function: A function that will be called on each self.list
                element. It should return True when an element's member has a
                value you're looking for.
                ex. lambda find_index_of_list_element_with_matching_id
                    list_element, id: list_element.id == id
                This will return True on the first element in self.list that
                has an id matching the id passed as the 2nd argument.
            search_match: In the previous example, id. The value you're hoping
                a member will match. If you want to find the first self.list
                element with an id of 0, this would be 0.

        Returns:
            The index of the first element in self.list to make search_function
            for search_match return True. -1 if no match was found.
        """
        for i in range(len(self.list)):
            if search_function(self.list[i], search_match) is True:
                return i
        return -1

    def is_desynced(self) -> bool:
        """Return whether memory and storage are out of sync.

        Return whether storage has been written to more recently than when it
        was least read from or written to by this instance of JSONList. This
        most often mean memory and storage in this thread are mismatched, and
        storage should be read from and overwrite memory to sync the two ASAP.
        This can happen frequently in multi-threaded situations where different
        threads are writing to and reading from the same file.

        Args:
            self: This JSONList

        Returns:
            Whether memory and storage are out of sync.
        """
        try:
            return os.path.getmtime(self.file_path) > self.last_sync
        except OSError:
            return True

    # TODO: In rare multi-threaded cases, because different threads cannot share
    #       file locks (to my knowledge), it is possible for one thread to write
    #       *while* another a reading, or multiple threads to write at the same
    #       time, overwriting each other's changes, because they both thought
    #       they were synced, and maybe they were! Lots of little finicky stuff.
    #       This is probably a common problem, maybe there's a library to help
    #       me if this becomes a real issue? Make a proper database?
    #       In the meantime, I can try:
    #       1. Make each guild only able to call N commands per second.
    #       2. Save each guild's lists in their own file instead of sharing.
    def sync(self) -> bool:
        """If self.is_desynced(), sync memory and storage.

        If self.is_desynced, overwrite the contents of memory with what is in
        storage.

        Args:
            self: This JSONList

        Returns:
            Whether a sync occurred (memory was overwritten).
        """
        if self.is_desynced():
            return self.read()
        return False
